# 研究模板

用于 `.planning/phases/XX-name/{phase}-RESEARCH.md` 的模板 — 规划前的综合生态系统研究。

**目的：** 记录 Claude 需要知道什么才能很好地实施阶段 — 不仅是"使用哪个库"，还有"专家如何构建这个"。

---

## 文件模板

```markdown
# 阶段 [X]: [名称] - 研究

**研究时间：** [日期]
**领域：** [主要技术/问题领域]
**置信度：** [高/中/低]

<user_constraints>
## 用户约束（来自 CONTEXT.md）

**关键：** 如果存在来自 /gsd:discuss-phase 的 CONTEXT.md，逐字复制锁定决策。规划者必须遵守这些。

### 锁定决策
[从 CONTEXT.md `## Decisions` 部分复制 — 这些是不可协商的]
- [决策 1]
- [决策 2]

### Claude 的裁量权
[从 CONTEXT.md 复制 — 研究者/规划者可以选择的领域]
- [领域 1]
- [领域 2]

### 延迟的想法（超出范围）
[从 CONTEXT.md 复制 — 不要研究或规划这些]
- [延迟 1]
- [延迟 2]

**如果不存在 CONTEXT.md：** 写"无用户约束 - 所有决策由 Claude 裁量"
</user_constraints>

<research_summary>
## 摘要

[2-3 段执行摘要]
- 研究了什么
- 标准方法是什么
- 关键建议

**主要建议：** [一句话可操作的指导]
</research_summary>

<standard_stack>
## 标准技术栈

此领域的既定库/工具：

### 核心
| 库 | 版本 | 目的 | 为何标准 |
|---------|---------|---------|--------------|
| [名称] | [版本] | [做什么] | [为何专家使用它] |
| [名称] | [版本] | [做什么] | [为何专家使用它] |

### 支持
| 库 | 版本 | 目的 | 何时使用 |
|---------|---------|---------|-------------|
| [名称] | [版本] | [做什么] | [用例] |
| [名称] | [版本] | [做什么] | [用例] |

### 考虑的替代方案
| 而非 | 可以使用 | 权衡 |
|------------|-----------|----------|
| [标准] | [替代方案] | [替代方案何时有意义] |

**安装：**
```bash
npm install [软件包]
# 或
yarn add [软件包]
```
</standard_stack>

<architecture_patterns>
## 架构模式

### 推荐的项目结构
```
src/
├── [文件夹]/        # [目的]
├── [文件夹]/        # [目的]
└── [文件夹]/        # [目的]
```

### 模式 1：[模式名称]
**什么：** [描述]
**何时使用：** [条件]
**示例：**
```typescript
// [来自 Context7/官方文档的代码示例]
```

### 模式 2：[模式名称]
**什么：** [描述]
**何时使用：** [条件]
**示例：**
```typescript
// [代码示例]
```

### 避免的反模式
- **[反模式]：** [为何不好，改为做什么]
- **[反模式]：** [为何不好，改为做什么]
</architecture_patterns>

<dont_hand_roll>
## 不要自己构建

看起来简单但有现有解决方案的问题：

| 问题 | 不要构建 | 改为使用 | 原因 |
|---------|-------------|-------------|-----|
| [问题] | [你会构建什么] | [库] | [边缘情况，复杂性] |
| [问题] | [你会构建什么] | [库] | [边缘情况，复杂性] |
| [问题] | [你会构建什么] | [库] | [边缘情况，复杂性] |

**关键洞察：** [为何此领域的自定义解决方案更差]
</dont_hand_roll>

<common_pitfalls>
## 常见陷阱

### 陷阱 1：[名称]
**出了什么问题：** [描述]
**为何发生：** [根本原因]
**如何避免：** [预防策略]
**警告信号：** [如何早期检测]

### 陷阱 2：[名称]
**出了什么问题：** [描述]
**为何发生：** [根本原因]
**如何避免：** [预防策略]
**警告信号：** [如何早期检测]

### 陷阱 3：[名称]
**出了什么问题：** [描述]
**为何发生：** [根本原因]
**如何避免：** [预防策略]
**警告信号：** [如何早期检测]
</common_pitfalls>

<code_examples>
## 代码示例

来自官方来源的验证模式：

### [常见操作 1]
```typescript
// 来源：[Context7/官方文档 URL]
[代码]
```

### [常见操作 2]
```typescript
// 来源：[Context7/官方文档 URL]
[代码]
```

### [常见操作 3]
```typescript
// 来源：[Context7/官方文档 URL]
[代码]
```
</code_examples>

<sota_updates>
## 最新技术（2024-2025）

最近发生了什么变化：

| 旧方法 | 当前方法 | 何时变化 | 影响 |
|--------------|------------------|--------------|--------|
| [旧] | [新] | [日期/版本] | [对实施的意义] |

**要考虑的新工具/模式：**
- [工具/模式]：[启用什么，何时使用]
- [工具/模式]：[启用什么，何时使用]

**已弃用/过时：**
- [东西]：[为何过时，什么替代了它]
</sota_updates>

<open_questions>
## 未解决问题

无法完全解决的事情：

1. **[问题]**
   - 我们知道的：[部分信息]
   - 不清楚的：[差距]
   - 建议：[在规划/执行期间如何处理]

2. **[问题]**
   - 我们知道的：[部分信息]
   - 不清楚的：[差距]
   - 建议：[如何处理]
</open_questions>

<sources>
## 来源

### 主要（高置信度）
- [Context7 库 ID] - [获取的主题]
- [官方文档 URL] - [检查的内容]

### 次要（中置信度）
- [WebSearch 经官方来源验证] - [发现 + 验证]

### 第三级（低置信度 - 需要验证）
- [仅 WebSearch] - [发现，在实施期间标记为验证]
</sources>

<metadata>
## 元数据

**研究范围：**
- 核心技术：[什么]
- 生态系统：[探索的库]
- 模式：[研究的模式]
- 陷阱：[检查的领域]

**置信度细分：**
- 标准技术栈：[高/中/低] - [原因]
- 架构：[高/中/低] - [原因]
- 陷阱：[高/中/低] - [原因]
- 代码示例：[高/中/低] - [原因]

**研究日期：** [日期]
**有效期至：** [估计 - 稳定技术 30 天，快速移动的 7 天]
</metadata>

---

*阶段：XX-name*
*研究完成：[日期]*
*准备好规划：[是/否]*
```

---

## 好示例

```markdown
# 阶段 3：3D 城市驾驶 - 研究

**研究时间：** 2025-01-20
**领域：** Three.js 3D Web 游戏，具有驾驶机制
**置信度：** 高

<research_summary>
## 摘要

研究了用于构建 3D 城市驾驶游戏的 Three.js 生态系统。标准方法使用 Three.js 与 React Three Fiber 用于组件架构，Rapier 用于物理，drei 用于常见辅助。

关键发现：不要自己构建物理或碰撞检测。Rapier（通过 @react-three/rapier）高效地处理车辆物理、地形碰撞和城市对象交互。自定义物理代码会导致错误和性能问题。

**主要建议：** 使用 R3F + Rapier + drei 技术栈。从 drei 的车辆控制器开始，添加 Rapier 车辆物理，使用实例化网格构建城市以获得性能。
</research_summary>

<standard_stack>
## 标准技术栈

### 核心
| 库 | 版本 | 目的 | 为何标准 |
|---------|---------|---------|--------------|
| three | 0.160.0 | 3D 渲染 | Web 3D 的标准 |
| @react-three/fiber | 8.15.0 | Three.js 的 React 渲染器 | 声明式 3D，更好的 DX |
| @react-three/drei | 9.92.0 | 辅助和抽象 | 解决常见问题 |
| @react-three/rapier | 1.2.1 | 物理引擎绑定 | R3F 的最佳物理 |

### 支持
| 库 | 版本 | 目的 | 何时使用 |
|---------|---------|---------|-------------|
| @react-three/postprocessing | 2.16.0 | 视觉效果 | 泛光、景深、运动模糊 |
| leva | 0.9.35 | 调试 UI | 调整参数 |
| zustand | 4.4.7 | 状态管理 | 游戏状态、UI 状态 |
| use-sound | 4.0.1 | 音频 | 引擎声音、环境音 |

### 考虑的替代方案
| 而非 | 可以使用 | 权衡 |
|------------|-----------|----------|
| Rapier | Cannon.js | Cannon 更简单但车辆性能较差 |
| R3F | 原生 Three | 如果没有 React 则使用原生，但 R3F DX 更好 |
| drei | 自定义辅助 | drei 经过实战测试，不要重新发明 |

**安装：**
```bash
npm install three @react-three/fiber @react-three/drei @react-three/rapier zustand
```
</standard_stack>

<architecture_patterns>
## 架构模式

### 推荐的项目结构
```
src/
├── components/
│   ├── Vehicle/          # 带物理的玩家汽车
│   ├── City/             # 城市生成和建筑
│   ├── Road/             # 道路网络
│   └── Environment/      # 天空、照明、雾
├── hooks/
│   ├── useVehicleControls.ts
│   └── useGameState.ts
├── stores/
│   └── gameStore.ts      # Zustand 状态
└── utils/
    └── cityGenerator.ts  # 程序化生成辅助
```

### 模式 1：具有 Rapier 物理的车辆
**什么：** 使用具有车辆特定设置的 RigidBody，而不是自定义物理
**何时使用：** 任何地面车辆
**示例：**
```typescript
// 来源：@react-three/rapier 文档
import { RigidBody, useRapier } from '@react-three/rapier'

function Vehicle() {
  const rigidBody = useRef()

  return (
    <RigidBody
      ref={rigidBody}
      type="dynamic"
      colliders="hull"
      mass={1500}
      linearDamping={0.5}
      angularDamping={0.5}
    >
      <mesh>
        <boxGeometry args={[2, 1, 4]} />
        <meshStandardMaterial />
      </mesh>
    </RigidBody>
  )
}
```

### 模式 2：城市的实例化网格
**什么：** 对重复对象使用 InstancedMesh（建筑、树木、道具）
**何时使用：** >100 个相似对象
**示例：**
```typescript
// 来源：drei 文档
import { Instances, Instance } from '@react-three/drei'

function Buildings({ positions }) {
  return (
    <Instances limit={1000}>
      <boxGeometry />
      <meshStandardMaterial />
      {positions.map((pos, i) => (
        <Instance key={i} position={pos} scale={[1, Math.random() * 5 + 1, 1]} />
      ))}
    </Instances>
  )
}
```

### 避免的反模式
- **在渲染循环中创建网格：** 创建一次，仅更新变换
- **不使用 InstancedMesh：** 单独的网格用于建筑会扼杀性能
- **自定义物理数学：** Rapier 每次都更好地处理它
</architecture_patterns>

<dont_hand_roll>
## 不要自己构建

| 问题 | 不要构建 | 改为使用 | 原因 |
|---------|-------------|-------------|-----|
| 车辆物理 | 自定义速度/加速度 | Rapier RigidBody | 车轮摩擦、悬挂、碰撞很复杂 |
| 碰撞检测 | 光线投射所有东西 | Rapier colliders | 性能、边缘情况、隧道 |
| 相机跟随 | 手动 lerp | drei CameraControls 或自定义与 useFrame | 平滑插值、边界 |
| 城市生成 | 纯随机放置 | 基于网格，使用噪声变化 | 随机看起来错误，网格可预测 |
| LOD | 手动距离检查 | drei <Detailed> | 处理转换、滞后 |

**关键洞察：** 3D 游戏开发有 40 多年的已解决问题。Rapier 实现了适当的物理模拟。drei 实现了适当的 3D 辅助。对抗这些会导致看起来像"游戏感觉"问题的错误，但实际上是物理边缘情况。
</dont_hand_roll>

<common_pitfalls>
## 常见陷阱

### 陷阱 1：物理隧道
**出了什么问题：** 快速物体穿过墙壁
**为何发生：** 默认物理步长对于速度来说太大
**如何避免：** 在 Rapier 中使用 CCD（连续碰撞检测）
**警告信号：** 对象随机出现在建筑物外

### 陷阱 2：绘制调用导致的性能死亡
**出了什么问题：** 许多建筑时游戏卡顿
**为何发生：** 每个网格 = 1 个绘制调用，数百个建筑 = 数百个调用
**如何避免：** 对相似对象使用 InstancedMesh，合并静态几何体
**警告信号：** GPU 受限，尽管场景简单但 FPS 低

### 陷阱 3：车辆"漂浮"感
**出了什么问题：** 汽车感觉不接地
**为何发生：** 缺少适当的车轮/悬挂模拟
**如何避免：** 使用 Rapier 车辆控制器或仔细调整质量/阻尼
**警告信号：** 汽车奇怪地反弹，不抓地过弯
</common_pitfalls>

<code_examples>
## 代码示例

### 基本 R3F + Rapier 设置
```typescript
// 来源：@react-three/rapier 入门
import { Canvas } from '@react-three/fiber'
import { Physics } from '@react-three/rapier'

function Game() {
  return (
    <Canvas>
      <Physics gravity={[0, -9.81, 0]}>
        <Vehicle />
        <City />
        <Ground />
      </Physics>
    </Canvas>
  )
}
```

### 车辆控制 Hook
```typescript
// 来源：社区模式，经 drei 文档验证
import { useFrame } from '@react-three/fiber'
import { useKeyboardControls } from '@react-three/drei'

function useVehicleControls(rigidBodyRef) {
  const [, getKeys] = useKeyboardControls()

  useFrame(() => {
    const { forward, back, left, right } = getKeys()
    const body = rigidBodyRef.current
    if (!body) return

    const impulse = { x: 0, y: 0, z: 0 }
    if (forward) impulse.z -= 10
    if (back) impulse.z += 5

    body.applyImpulse(impulse, true)

    if (left) body.applyTorqueImpulse({ x: 0, y: 2, z: 0 }, true)
    if (right) body.applyTorqueImpulse({ x: 0, y: -2, z: 0 }, true)
  })
}
```
</code_examples>

<sota_updates>
## 最新技术（2024-2025）

| 旧方法 | 当前方法 | 何时变化 | 影响 |
|--------------|------------------|--------------|--------|
| cannon-es | Rapier | 2023 | Rapier 更快，维护更好 |
| 原生 Three.js | React Three Fiber | 2020+ | R3F 现在是 React 应用的标准 |
| 手动 InstancedMesh | drei <Instances> | 2022 | 更简单的 API，处理更新 |

**要考虑的新工具/模式：**
- **WebGPU：** 即将到来但游戏尚未生产就绪（2025）
- **drei Gltf 辅助：** <useGLTF.preload> 用于加载屏幕

**已弃用/过时：**
- **cannon.js（原始）：** 使用 cannon-es 分支或更好的 Rapier
- **物理的手动光线投射：** 只需使用 Rapier colliders
</sota_updates>

<sources>
## 来源

### 主要（高置信度）
- /pmndrs/react-three-fiber - 入门、hooks、性能
- /pmndrs/drei - instances、controls、helpers
- /dimforge/rapier-js - 物理设置、车辆物理

### 次要（中置信度）
- Three.js 论坛"城市驾驶游戏"主题 - 经文档验证的模式
- R3F 示例存储库 - 验证代码有效

### 第三级（低置信度 - 需要验证）
- 无 - 所有发现已验证
</sources>

<metadata>
## 元数据

**研究范围：**
- 核心技术：Three.js + React Three Fiber
- 生态系统：Rapier、drei、zustand
- 模式：车辆物理、实例化、城市生成
- 陷阱：性能、物理、感觉

**置信度细分：**
- 标准技术栈：高 - 经 Context7 验证，广泛使用
- 架构：高 - 来自官方示例
- 陷阱：高 - 在论坛中记录，在文档中验证
- 代码示例：高 - 来自 Context7/官方来源

**研究日期：** 2025-01-20
**有效期至：** 2025-02-20（30 天 - R3F 生态系统稳定）
</metadata>

---

*阶段：03-city-driving*
*研究完成：2025-01-20*
*准备好规划：是*
```

---

## 指南

**何时创建：**
- 在规划小众/复杂领域的阶段之前
- 当 Claude 的训练数据可能过时或稀疏时
- 当"专家如何做此"比"使用哪个库"更重要时

**结构：**
- 对部分标记使用 XML 标签（匹配 GSD 模板）
- 七个核心部分：摘要、standard_stack、architecture_patterns、dont_hand_roll、common_pitfalls、code_examples、sources
- 所有部分都需要（驱动全面研究）

**内容质量：**
- 标准技术栈：特定版本，而不仅仅是名称
- 架构：包括来自权威来源的实际代码示例
- 不要自己构建：明确说明不要自己解决什么问题
- 陷阱：包括警告信号，而不仅仅是"不要这样做"
- 来源：诚实标记置信度级别

**与规划的集成：**
- RESEARCH.md 作为 PLAN.md 中的 @context 引用加载
- 标准技术栈通知库选择
- 不要自己构建防止自定义解决方案
- 陷阱通知验证标准
- 代码示例可以在任务操作中引用

**创建后：**
- 文件位于阶段目录：`.planning/phases/XX-name/{phase}-RESEARCH.md`
- 在规划工作流期间引用
- plan-phase 在存在时自动加载它
